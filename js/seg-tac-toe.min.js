/*

  Seg-Tac-Toe
    by John "Seg" Seggerson
    http://theseg.github.io/

*/

/**
 * Playfield settings.
 */
var playField = {
    "width":3,
    "height":3,
	"winLength":3,
	"coreCellIDName":"stt-main-cell-",
	"winConditions": [
		{
			"winAnimationClass":"winCondition-diag-00",
			"cells":[
				{"x":0,"y":0},
				{"x":1,"y":1},
				{"x":2,"y":2},
			],
		},
		{
			"winAnimationClass":"winCondition-diag-01",
			"cells":[
				{"x":0,"y":2},
				{"x":1,"y":1},
				{"x":2,"y":0},
			],
		},
		{
			"winAnimationClass":"winCondition-hor-00",
			"cells":[
				{"x":0,"y":0},
				{"x":0,"y":1},
				{"x":0,"y":2},
			],
		},
		{
			"winAnimationClass":"winCondition-hor-01",
			"cells":[
				{"x":1,"y":0},
				{"x":1,"y":1},
				{"x":1,"y":2},
			],
		},
		{
			"winAnimationClass":"winCondition-hor-02",
			"cells":[
				{"x":2,"y":0},
				{"x":2,"y":1},
				{"x":2,"y":2},
			],
		},
		{
			"winAnimationClass":"winCondition-ver-00",
			"cells":[
				{"x":0,"y":0},
				{"x":1,"y":0},
				{"x":2,"y":0},
			],
		},
		{
			"winAnimationClass":"winCondition-ver-01",
			"cells":[
				{"x":0,"y":1},
				{"x":1,"y":1},
				{"x":2,"y":1},
			],
		},
		{
			"winAnimationClass":"winCondition-ver-02",
			"cells":[
				{"x":0,"y":2},
				{"x":1,"y":2},
				{"x":2,"y":2},
			],
		},
	],
};

/**
 * Define types of gameplay status.
 */
var gamePlayStatusTypes = {
	"inprogress":0,
	"winner":1,
	"draw":2,
};

/**
 * Lists order and existance of players.
 */
var players = ["X","O"];

/**
 * Properties related to player types.
 */
var playerProps = {
    "X": {
        "shortname": "X",
        "faIconClass": "glyphicon-remove-circle",
		"cellClass": "input-claimed-x",
    },
    "O": {
        "shortname": "O",
        "faIconClass": "glyphicon-record",
		"cellClass": "input-claimed-o",
    }
};

/**
 * Inital status; Reset functions always revert to this set.
 */
var initalStatus = {
	"currentPlayer":"X",
	"state":gamePlayStatusTypes.inprogress,
	"winner":null,
	"winCondition":null,
};

/**
 * All functions use currentStatus for state information.
 */
var currentStatus = $.extend( {}, initalStatus );

/**
 * Reset all variables.
 */
function sttResetVars() {
	currentStatus = $.extend( {}, initalStatus );
}

/**
 * Initalize all variables.
 */
function sttInitVars() {
	sttResetVars();
}


/* **********************************************
     Begin stt-ui.js
********************************************** */

/*

  Seg-Tac-Toe
    by John "Seg" Seggerson
    http://theseg.github.io/

*/

/**
 * Variables
 */
var targetMarkCellClasses;

/**
 * Initializes the UI.
 */
function sttInitUI()
{
	targetMarkCellClasses = [
		"input-claimed"
	];
	for ( var playerName in playerProps ) {
		targetMarkCellClasses.push( playerProps[playerName].cellClass );
	}
	sttResetUI();
}

/**
 * Resets UI to inital states.
 */
function sttResetUI()
{
	sttUIUnMarkCellAll();
	sttUICurrentPlayer();
}

/**
 * Generates HTML code of player icon.
 */
function sttUIGetPlayerIcon( targetPlayer )
{
	// Returns HTML of the target player's icon.
	var returnString = '<span class="glyphicon ' + playerProps[ targetPlayer.toUpperCase() ].faIconClass + '"></span>';
	
	return returnString;
}

/**
 * Marks target cell to the target player.
 * 
 * @param targetCell object
 * 		jQuery element of cell to mark.
 * @param targetPlayer string
 * 		String of player to tag cell.
 * @return bool
 * 		TRUE if targetCell was marked with targetPlayer.
 */
function sttUIMarkcell( targetCell , targetPlayer )
{
	var returnVar = false;
	// Check to make sure square isn't already assigned.
	if ( targetCell.hasClass("input-claimed") === false ) {
		// Assign player's CSS class to target element.
		targetCell.addClass( "input-claimed " + playerProps[targetPlayer].cellClass);
		$( "#"+targetCell.attr("id")+" .stt-icon-current-state").html(
			'<i class="glyphicon '+playerProps[targetPlayer].faIconClass+'"></i>'
		);
		returnVar = true;
	} else {
		// The cell is already claimed.
	}
	
	return returnVar;
}


/**
 * Umarks target cell of all players.
 * 
 * @param targetCell object
 * 		jQuery element of cell to unmark.
 */
function sttUIUnMarkCell( targetCell )
{
	targetCell.removeClass( targetMarkCellClasses.join(" ") );
	$( "#"+targetCell.attr("id")+" .stt-icon-current-state").html( '' );
}

/**
 * Umarks all cells of all players.
 */
function sttUIUnMarkCellAll()
{
	$(".stt-cell").each(function(i,a) {
		sttUIUnMarkCell( $(this) );
	});
}

/**
 * Dresses End Of Game modal with target text.
 * 
 * @param inputTitle string
 * 		HTML string of message title.
 * @param inputBody string
 * 		HTML string of message body.
 * @param inputIcon string
 * 		HTML string of icon to feature.
 */
function sttUIEOFModalDress( inputTitle , inputBody, inputIcon )
{
	$('#model-eog .modal-title').html( inputTitle );
	
	var compiledBody = '<div class="featured-icon">'+inputIcon+'</div>\n<p>'+inputBody+'</p>';
	
	$('#model-eog .modal-body').html( compiledBody );
}

/**
 * Displays End Of Game modal screen. Includes updating based on current state.
 * 
 * @return bool
 * 		FALSE if currentStatus.state is inprogress.
 */
function sttUIEOF() {
	// End of Game Display
	
	// If we're still in progress, don't do anything.
	if ( currentStatus.state === gamePlayStatusTypes.inprogress ) {
		return false;
	}
	
	// Closing Pre-animations
	
	// Dress the Modal.
	switch( currentStatus.state )
	{
		case gamePlayStatusTypes.winner:
			sttUIEOFModalDress(
				"Congratulations!!!" ,
				"Player "+ sttUIGetPlayerIcon( currentStatus.winner ) +" won the game!",
				sttUIGetPlayerIcon( currentStatus.winner )
			);
			break;
		case gamePlayStatusTypes.draw:
			sttUIEOFModalDress(
				"DRAW!" , 
				"The game ended in a draw.<br>Why not try a <strong>New Game</strong>?",
				'<i class="icon-question-sign"></i>'
			);
			break;
	}
	
	// Show Modal
	$('#model-eog').modal('show');
	
	return true;
}

/**
 * Sets up playfield style for the active player.
 * 
 * @return bool
 * 		FALSE if game is currently NOT inprogress.
 */
function sttUICurrentPlayer() {
	// Clean up current settings.
	$("#stt-main-playfield").removeClass("stt-current-player-X stt-current-player-O");
	
	// Don't do anything if we're not in progress of a game.
	if ( currentStatus.state !== gamePlayStatusTypes.inprogress ) {
		return false;
	}
	
	// Set the proper classes.
	$("#stt-main-playfield").addClass( "stt-current-player-" + currentStatus.currentPlayer.toUpperCase() );
	
	return true;
}


/* **********************************************
     Begin stt-input.js
********************************************** */

/*

  Seg-Tac-Toe
    by John "Seg" Seggerson
    http://theseg.github.io/

*/

/**
 * Initializes the Input system.
 */
function sttInitInput()
{
	$(".stt-cell").click( function() {
		sttInputBind( this );
	}).hover(
		function() {
			sttInputOnHover( this );
		},
		function() {
			sttInputOnHoverOut( this );
		}
	);
	$(".stt-reset-function").click( function() {
		sttReset();
	});
}

/**
 * Resets the Input system.
 */
function sttResetInput()
{
	
}

/**
 * Advances the current player's turn.
 */
function sttInputAdvancePlayer()
{
	
	var nextIndex = ( $.inArray( currentStatus.currentPlayer , players ) + 1 );
	if ( nextIndex < 0 ) {
		console.error( "Players array is incorrect.", "sttInputAdvancePlayer();");
	} else if ( nextIndex >= players.length ) {
		currentStatus.currentPlayer = players[0];
	} else {
		currentStatus.currentPlayer = players[ nextIndex ];
	}
	
}

/**
 * Functions to run when a turn is made by a player.
 */
function sttInputEndTurn()
{
	sttSetWinStatus();
	sttUICurrentPlayer();
}

/**
 * Binding input function on a cell.
 * 
 * @param targetElement object
 * 		jQuery object of target cell to mark.
 */
function sttInputBind( targetElement )
{
	
	if ( currentStatus.state === gamePlayStatusTypes.inprogress ) {
		if ( sttUIMarkcell( $(targetElement) , currentStatus.currentPlayer ) ) {
			// Returns TRUE only if cell is previously unclaimed.
			sttInputAdvancePlayer();
			sttInputEndTurn();
		}
	}
	
}

/**
 * Binding OnHover function on a cell.
 * 
 * @param targetElement object
 * 		jQuery object of target cell to mark.
 * @return bool
 * 		TRUE on successful call.
 */
function sttInputOnHover( targetElement )
{
	var targetParent = $(targetElement);
	if ( currentStatus.state === gamePlayStatusTypes.inprogress && ( targetParent.hasClass("input-claimed") === false ) ) {
		var target = "#"+targetParent.attr("id")+" .stt-icon-current-state";
		$(target).html('<i class="glyphicon '+playerProps[currentStatus.currentPlayer].faIconClass+'"></i>');
	}
	
	return true;
}

/**
 * Binding OnHoverOut function on a cell.
 * 
 * @param targetElement object
 * 		jQuery object of target cell to mark.
 * @return bool
 * 		TRUE on successful call.
 */
function sttInputOnHoverOut( targetElement )
{
	var targetParent = $(targetElement);
	if ( currentStatus.state === gamePlayStatusTypes.inprogress && ( targetParent.hasClass("input-claimed") === false ) ) {
		var target = "#"+targetParent.attr("id")+" .stt-icon-current-state";
		$(target).html("");
	}
	
	return true;
}

/* **********************************************
     Begin stt-logic.js
********************************************** */

/*

  Seg-Tac-Toe
    by John "Seg" Seggerson
    http://theseg.github.io/

*/


/**
 * Initializes the Logic system.
 */
function sttInitLogic()
{
	
}

/**
 * Resets the Logic system.
 */
function sttResetLogic()
{
	
}

/**
 * Returns the ID string of a cell, given the X Y coordinates.
 * 
 * @param inputXY array
 * 		Array in x,y format.
 * @return string
 * 		String of ID name of requested cell.
 */
function sttCellXYtoID( inputXY )
{
	return playField.coreCellIDName + inputXY.x + "-" + inputXY.y;
}

/**
 * Main logic engine to determine win/loose/draw state.
 * 
 * @param targetID
 * 		Array in x,y format.
 * @return object
 * 		Returns object of results.
 */
function sttGetRowStatus( targetID )
{
	// Variable declars
	var returnVar = {
		"state":gamePlayStatusTypes.inprogress,
		"winner":null,
		"winCondition":null,
	};
	var targetPlayer = null;
	var targetElement = $(targetID);
	
	// What player are we looking at?
	for ( var targetClass in playerProps ) {
		if ( targetElement.hasClass(playerProps[targetClass].cellClass) ) {
			targetPlayer = targetClass;
		}
	}
	
	if ( targetPlayer !== null ) {
		for ( var targetCondition in playField.winConditions ) {
			var cellCount = 0;
			for ( var targetCell in playField.winConditions[targetCondition].cells ) {
				var targetXY = playField.winConditions[targetCondition].cells[targetCell];
				var targetStatus = $( "#"+sttCellXYtoID( targetXY ) ).hasClass( playerProps[targetPlayer].cellClass );
				if ( targetStatus === true ) {
					cellCount++;
				}
			}
			if ( cellCount >= playField.winLength ) {
				// PLAYER HAS WON!
				returnVar.state = gamePlayStatusTypes.winner;
				returnVar.winner = targetPlayer;
				returnVar.winCondition = targetCondition;
				break;
			}
		}
		
	} else {
		// Unclaimed square;
		returnVar.state = gamePlayStatusTypes.inprogress;
		returnVar.winner = null;
	}
	
	return returnVar;
	
}

/**
 * Runs logic engine to check win conditions, then reports to state variables on results.
 * 
 * @return bool
 * 		TRUE on successful compliation.
 */
function sttSetWinStatus()
{
	
	// Variable declars
	var doEval = false;
	var returnVar = {
		"state":0,
		"winner":null,
		"winCondition":null,
	};
	var playerSquares = {};
	
	// Does any one player have more than three owned squares? If so, we can eval.
	for ( var targetPlayer in playerProps ) {
		// Grab the claimed cells for each player.
		playerSquares[targetPlayer] = $("."+playerProps[targetPlayer].cellClass);
		
		// Check if there's at least enough claimed squares for evaluation.
		if ( playerSquares[targetPlayer].length >= playField.winLength ) {
			doEval = true;
		}
	}
	
	// May we evaluate?
	if ( doEval === true ) {
		
		// Cycle though each claimed cell to see if we have a row.
		for ( var targetPlayerCells in playerSquares ) {
			for ( var targetCell=0; targetCell < playerSquares[targetPlayerCells].length; targetCell++ ) {
				var returnRowStatus = sttGetRowStatus( playerSquares[targetPlayerCells][targetCell] );
				if ( returnRowStatus.state !== gamePlayStatusTypes.inprogress ) {
					returnVar = returnRowStatus;
					break;
				}
			}
			if ( returnVar.state !== gamePlayStatusTypes.inprogress ) {
				break;
			}
		}
		
		// Are we at a full board?
		if ( ( returnVar.state === gamePlayStatusTypes.inprogress ) && ( $(".input-claimed").length >= $(".stt-cell").length ) ) {
			// All squares filled.
			returnVar.state = gamePlayStatusTypes.draw;
		}
		
	} else {
		// The defacto returnVar of 0:null state is already defined.
	}
	
	// Set Current Conditions.
	currentStatus.state = returnVar.state;
	currentStatus.winner = returnVar.winner;
	currentStatus.winCondition = returnVar.winCondition;
	
	sttLogicEOG();
	
	return true;
}

/**
 * Checks if game is no longer in progress. Runs EOG procedure if there is an outcome.
 */
function sttLogicEOG() {
	// Check the status and launches end of game acordingly.
	if ( currentStatus.state > gamePlayStatusTypes.inprogress ) {
		// Run EOG functions.
		sttUIEOF();
	}
	
	return true;
}


/* **********************************************
     Begin seg-tac-toe.js
********************************************** */

/*

  Seg-Tac-Toe
    by John "Seg" Seggerson
    http://theseg.github.io/

*/

// @codekit-prepend "stt-vars.js";
// @codekit-prepend "stt-ui.js";
// @codekit-prepend "stt-input.js";
// @codekit-prepend "stt-logic.js";

/**
 * Runs all Initalizing functions.
 */
function sttInit() {
	sttInitVars();
	sttInitLogic();
	sttInitUI();
	sttInitInput();
}

/**
 * Runs all Reset functions.
 */
function sttReset() {
	sttResetVars();
	sttResetLogic();
	sttResetUI();
	sttResetInput();
}

/**
 * Starts application when document is loaded.
 */
$( document ).ready(function() {
	sttInit();
});
